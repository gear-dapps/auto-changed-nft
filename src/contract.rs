use auto_changed_nft_io::{InitNFT, IoNFT, NFTAction, NFTEvent, NFTMetadata};
use gear_lib::non_fungible_token::{io::NFTTransfer, nft_core::*, state::*, token::*};
use gear_lib_derive::{NFTCore, NFTMetaState, NFTStateKeeper};
use gmeta::Metadata;
use gstd::{
    errors::Result as GstdResult,
    exec::{self},
    msg,
    prelude::*,
    ActorId, MessageId,
};
use hashbrown::HashMap;
use primitive_types::{H256, U256};

const DELAY: u32 = 5;
const DEFAULT_UPDATE_PERIODS: u32 = 2;

#[derive(Debug, Default, NFTStateKeeper, NFTCore, NFTMetaState)]
pub struct AutoChangedNft {
    #[NFTStateField]
    pub token: NFTState,
    pub token_id: TokenId,
    pub owner: ActorId,
    pub transactions: HashMap<H256, NFTEvent>,
    pub dynamic_data: Vec<u8>,
    pub rest_update_periods: u32,
}

static mut CONTRACT: Option<AutoChangedNft> = None;

#[no_mangle]
unsafe extern "C" fn init() {
    let config: InitNFT = msg::load().expect("Unable to decode InitNFT");
    if config.royalties.is_some() {
        config.royalties.as_ref().expect("Unable to g").validate();
    }
    let nft = AutoChangedNft {
        token: NFTState {
            name: config.name,
            symbol: config.symbol,
            base_uri: config.base_uri,
            royalties: config.royalties,
            ..Default::default()
        },
        owner: msg::source(),
        rest_update_periods: DEFAULT_UPDATE_PERIODS,
        ..Default::default()
    };

    let periods = nft.rest_update_periods;
    CONTRACT = Some(nft);

    let data = format!("Rest Update Periods: {}", periods)
        .as_bytes()
        .to_vec();

    let payload = NFTAction::UpdateDynamicData {
        transaction_id: 1,
        data,
    };
    msg::send_delayed(exec::program_id(), payload, 0, DELAY).expect("Cant send delayed msg");
}

#[no_mangle]
unsafe extern "C" fn handle() {
    let action: NFTAction = msg::load().expect("Could not load NFTAction");
    let nft = CONTRACT.get_or_insert(Default::default());
    match action {
        NFTAction::Mint {
            transaction_id,
            token_metadata,
        } => {
            msg::reply(
                nft.process_transaction(transaction_id, |nft| {
                    NFTEvent::Transfer(MyNFTCore::mint(nft, token_metadata))
                }),
                0,
            )
            .expect("Error during replying with `NFTEvent::Transfer`");
        }
        NFTAction::Burn {
            transaction_id,
            token_id,
        } => {
            msg::reply(
                nft.process_transaction(transaction_id, |nft| {
                    NFTEvent::Transfer(NFTCore::burn(nft, token_id))
                }),
                0,
            )
            .expect("Error during replying with `NFTEvent::Transfer`");
        }
        NFTAction::Transfer {
            transaction_id,
            to,
            token_id,
        } => {
            msg::reply(
                nft.process_transaction(transaction_id, |nft| {
                    NFTEvent::Transfer(NFTCore::transfer(nft, &to, token_id))
                }),
                0,
            )
            .expect("Error during replying with `NFTEvent::Transfer`");
        }
        NFTAction::TransferPayout {
            transaction_id,
            to,
            token_id,
            amount,
        } => {
            msg::reply(
                nft.process_transaction(transaction_id, |nft| {
                    NFTEvent::TransferPayout(NFTCore::transfer_payout(nft, &to, token_id, amount))
                }),
                0,
            )
            .expect("Error during replying with `NFTEvent::TransferPayout`");
        }
        NFTAction::NFTPayout { owner, amount } => {
            msg::reply(
                NFTEvent::NFTPayout(NFTCore::nft_payout(nft, &owner, amount)),
                0,
            )
            .expect("Error during replying with `NFTEvent::NFTPayout`");
        }
        NFTAction::Approve {
            transaction_id,
            to,
            token_id,
        } => {
            msg::reply(
                nft.process_transaction(transaction_id, |nft| {
                    NFTEvent::Approval(NFTCore::approve(nft, &to, token_id))
                }),
                0,
            )
            .expect("Error during replying with `NFTEvent::Approval`");
        }
        NFTAction::Owner { token_id } => {
            msg::reply(
                NFTEvent::Owner {
                    owner: NFTCore::owner_of(nft, token_id),
                    token_id,
                },
                0,
            )
            .expect("Error during replying with `NFTEvent::Owner`");
        }
        NFTAction::IsApproved { to, token_id } => {
            msg::reply(
                NFTEvent::IsApproved {
                    to,
                    token_id,
                    approved: NFTCore::is_approved_to(nft, &to, token_id),
                },
                0,
            )
            .expect("Error during replying with `NFTEvent::IsApproved`");
        }
        NFTAction::DelegatedApprove {
            transaction_id,
            message,
            signature,
        } => {
            msg::reply(
                nft.process_transaction(transaction_id, |nft| {
                    NFTEvent::Approval(NFTCore::delegated_approve(nft, message, signature))
                }),
                0,
            )
            .expect("Error during replying with `NFTEvent::Approval`");
        }
        NFTAction::Clear { transaction_hash } => nft.clear(transaction_hash),
        NFTAction::UpdateDynamicData {
            transaction_id,
            data,
        } => {
            let payload = nft.process_transaction(transaction_id, |nft| {
                let data_hash = H256::from(sp_core_hashing::blake2_256(&data));
                if nft.rest_update_periods > 0 {
                    nft.dynamic_data = data;
                    nft.rest_update_periods -= 1;
                    let periods = nft.rest_update_periods;
                    let data = format!("Rest Update Periods: {}", periods)
                        .as_bytes()
                        .to_vec();
                    let payload = NFTAction::UpdateDynamicData {
                        transaction_id: transaction_id + 1,
                        data,
                    };
                    let reservation_id = gstd::ReservationId::reserve(1_000_000_000, DELAY)
                        .expect("reservation across executions");
                    msg::send_delayed_from_reservation(
                        reservation_id,
                        exec::program_id(),
                        payload,
                        0,
                        DELAY,
                    )
                    .expect("Can't send delayed");
                } else {
                    nft.dynamic_data = "Expired".as_bytes().to_vec();
                }
                NFTEvent::Updated { data_hash }
            });
            msg::reply(payload, 0).expect("Error during replying with `NFTEvent::Updated`");
        }
    };
}

pub trait MyNFTCore: NFTCore {
    fn mint(&mut self, token_metadata: TokenMetadata) -> NFTTransfer;
}

impl MyNFTCore for AutoChangedNft {
    fn mint(&mut self, token_metadata: TokenMetadata) -> NFTTransfer {
        let transfer = NFTCore::mint(self, &msg::source(), self.token_id, Some(token_metadata));
        self.token_id = self.token_id.saturating_add(U256::one());
        transfer
    }
}

impl AutoChangedNft {
    fn process_transaction(
        &mut self,
        transaction_id: u64,
        action: impl FnOnce(&mut AutoChangedNft) -> NFTEvent,
    ) -> NFTEvent {
        let transaction_hash = get_hash(&msg::source(), transaction_id);

        if let Some(nft_event) = self.transactions.get(&transaction_hash) {
            nft_event.clone()
        } else {
            let nft_event = action(self);

            self.transactions
                .insert(transaction_hash, nft_event.clone());

            nft_event
        }
    }

    fn clear(&mut self, transaction_hash: H256) {
        assert_eq!(
            msg::source(),
            exec::program_id(),
            "Not allowed to clear transactions"
        );
        self.transactions.remove(&transaction_hash);
    }
}

#[no_mangle]
extern "C" fn metahash() {
    let metahash: [u8; 32] = include!("../.metahash");
    reply(metahash).expect("Failed to encode or reply with `[u8; 32]` from `metahash()`");
}

fn static_mut_state() -> &'static AutoChangedNft {
    unsafe { CONTRACT.get_or_insert(Default::default()) }
}

fn common_state() -> <NFTMetadata as Metadata>::State {
    static_mut_state().into()
}

#[no_mangle]
extern "C" fn state() {
    reply(common_state())
        .expect("Failed to encode or reply with `<NFTMetadata as Metadata>::State` from `state()`");
}

fn reply(payload: impl Encode) -> GstdResult<MessageId> {
    msg::reply(payload, 0)
}

pub fn get_hash(account: &ActorId, transaction_id: u64) -> H256 {
    let account: [u8; 32] = (*account).into();
    let transaction_id = transaction_id.to_be_bytes();
    sp_core_hashing::blake2_256(&[account.as_slice(), transaction_id.as_slice()].concat()).into()
}

impl From<&AutoChangedNft> for IoNFT {
    fn from(value: &AutoChangedNft) -> Self {
        let AutoChangedNft {
            token,
            token_id,
            owner,
            transactions,
            dynamic_data,
            rest_update_periods: update_periods,
        } = value;

        let transactions = transactions
            .iter()
            .map(|(key, event)| (*key, event.clone()))
            .collect();
        Self {
            token: token.into(),
            token_id: *token_id,
            owner: *owner,
            transactions,
            dynamic_data: dynamic_data.clone(),
            update_periods: *update_periods,
        }
    }
}
